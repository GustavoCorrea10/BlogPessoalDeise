// PACOTE: DEFINE O "ENDEREÇO" DESTA CLASSE DENTRO DO SEU PROJETO. 
// ELA ESTÁ NA "PASTA" DE SEGURANÇA.
package com.gustavo.blogpessoaldeise.security;

// IMPORTAÇÕES: TRAZ AS "FERRAMENTAS" DE OUTRAS PARTES DO CÓDIGO QUE ESTA CLASSE PRECISA USAR.
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import com.gustavo.blogpessoaldeise.model.Usuario;
import com.gustavo.blogpessoaldeise.repository.UsuarioRepository;


// @SERVICE: ANOTAÇÃO QUE TRANSFORMA ESTA CLASSE EM UM "SERVIÇO" GERENCIADO PELO SPRING.
// O SPRING CRIA UMA INSTÂNCIA (UM OBJETO) DESTA CLASSE AUTOMATICAMENTE E A DEIXA PRONTA PARA SER USADA EM OUTROS LUGARES.
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	// DECLARAÇÃO DA CLASSE.
	// 'PUBLIC': QUALQUER PARTE DO PROJETO PODE ACESSÁ-LA.
	// 'IMPLEMENTS USERDETAILSSERVICE': ESTA É A PARTE MAIS IMPORTANTE. A CLASSE "ASSINA UM CONTRATO" COM O SPRING SECURITY,
	// PROMETENDO QUE ELA SABE COMO CARREGAR OS DADOS DE UM USUÁRIO A PARTIR DE UM NOME DE USUÁRIO (NO NOSSO CASO, O E-MAIL).

	
	
	
	
	
	// @AUTOWIRED: PEDE AO SPRING PARA "INJETAR" (COLOCAR AQUI) UMA INSTÂNCIA FUNCIONAL DO 'USUARIOREPOSITORY'. 
	// É COMO PEDIR UMA FERRAMENTA ESPECÍFICA DA CAIXA DE FERRAMENTAS DO SPRING.
	@Autowired
	// CAMPO PARA GUARDAR O REPOSITÓRIO DE USUÁRIO.
	// 'PRIVATE': ESTE CAMPO SÓ PODE SER ACESSADO DIRETAMENTE DENTRO DESTA CLASSE.
	private UsuarioRepository usuarioRepository;


	
	
	
	
	
	
	
	
	
	// @OVERRIDE: INDICA QUE O MÉTODO ABAIXO ESTÁ "SOBRESCREVENDO" UM MÉTODO EXIGIDO PELA INTERFACE 'USERDETAILSSERVICE'. 
	// ESTAMOS CUMPRINDO A NOSSA PARTE DO "CONTRATO".
	@Override
	public UserDetails loadUserByUsername(String userEmail) throws UsernameNotFoundException {
		// ESTE É O ÚNICO MÉTODO QUE O "CONTRATO" 'USERDETAILSSERVICE' EXIGE.
		// O SPRING SECURITY CHAMA ESTE MÉTODO AUTOMATICAMENTE DURANTE O PROCESSO DE LOGIN.
		// 'PUBLIC USERDETAILS': O MÉTODO É PÚBLICO E DEVE RETORNAR UM OBJETO DO TIPO 'USERDETAILS', QUE É O FORMATO DE USUÁRIO QUE O SPRING SECURITY ENTENDE.
		// 'LOADUSERBYUSERNAME': NOME PADRÃO DO MÉTODO, NÃO PODE SER ALTERADO.
		// '(STRING USEREMAIL)': ELE RECEBE O E-MAIL (QUE O USUÁRIO DIGITOU NA TELA DE LOGIN) COMO UM PARÂMETRO DO TIPO STRING.

		
		// PASSO 1: BUSCAR O USUÁRIO NO BANCO DE DADOS.
		// USA O 'USUARIOREPOSITORY' (NOSSO ACESSO AO BANCO DE DADOS) PARA CHAMAR O MÉTODO 'FINDYBYEMAIL'.
		// ELE TENTA ENCONTRAR UM USUÁRIO NO BANCO DE DADOS CUJO E-MAIL SEJA IGUAL AO 'USEREMAIL' RECEBIDO.
		// O RESULTADO É GUARDADO EM UM 'OPTIONAL', UMA "CAIXA" ESPECIAL QUE PODE CONTER UM USUÁRIO OU ESTAR VAZIA, EVITANDO ERROS.
		Optional<Usuario> email = usuarioRepository.findByEmail(userEmail);

		
		// PASSO 2: VERIFICAR SE O USUÁRIO FOI ENCONTRADO.
		// VERIFICA SE A "CAIXA" 'OPTIONAL' CONTÉM UM OBJETO 'USUARIO'. OU SEJA, "O USUÁRIO FOI ENCONTRADO NO BANCO DE DADOS?"
		if (email.isPresent()) {
			// SE O USUÁRIO FOI ENCONTRADO, NÓS O TIRAMOS DA "CAIXA" COM 'EMAIL.GET()'.
			// EM SEGUIDA, CRIAMOS UMA NOVA INSTÂNCIA DE 'USERDETAILSIMPL' (O "CARTÃO DE IDENTIDADE" PADRÃO DO SPRING) PASSANDO O NOSSO OBJETO 'USUARIO'.
			// ESTA LINHA "TRADUZ" O NOSSO USUÁRIO DO BANCO PARA O FORMATO QUE O SPRING SECURITY CONSEGUE ENTENDER.
			// O MÉTODO ENTÃO RETORNA ESSE "CARTÃO DE IDENTIDADE" PARA O SPRING SECURITY, QUE CONTINUARÁ O PROCESSO DE LOGIN (VERIFICANDO A SENHA, ETC.).
			return new UserDetailsImpl(email.get());
		} else { // SE A "CAIXA" ESTIVER VAZIA, SIGNIFICA QUE NENHUM USUÁRIO COM AQUELE E-MAIL FOI ENCONTRADO NO BANCO DE DADOS.
			
			// LANÇAMOS A EXCEÇÃO 'USERNAMENOTFOUNDEXCEPTION', QUE É A EXCEÇÃO ESPECÍFICA E CORRETA QUE O SPRING SECURITY ESPERA RECEBER NESTE CASO.
			// ISSO INFORMA AO SPRING DE FORMA SEGURA QUE A AUTENTICAÇÃO FALHOU PORQUE O USUÁRIO NÃO EXISTE.
			// O SPRING ENTÃO RETORNARÁ UMA MENSAGEM DE ERRO GENÉRICA (COMO "CREDENCIAIS INVÁLIDAS") AO CLIENTE.
			throw new UsernameNotFoundException("Usuário não encontrado: " + userEmail);
		}
			
	}
	
}